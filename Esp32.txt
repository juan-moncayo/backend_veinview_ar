/*
 * VeinView AR - ESP32
 * Sistema de captura de datos para practicas de canalizacion venosa
 * Sensores: MPU6050 (inclinacion) + HX711 (celda de carga)
 * VERSION MEJORADA: Monitoreo continuo de sensores
 */

#include <WiFi.h>
#include <HTTPClient.h>
#include <Wire.h>
#include <MPU6050.h>
#include <HX711.h>
#include <ArduinoJson.h>

// ==================== CONFIGURACION WiFi ====================
const char* WIFI_SSID = "WIFI_UCC_ESTUDIANTES";
const char* WIFI_PASSWORD = "E5tud14nt3s_BplC00r*";

// ==================== CONFIGURACION SERVIDOR ====================
const char* SERVER_URL = "http://10.162.34.94:8000/api/placa";

// ==================== CONFIGURACION API ====================
String API_KEY = "";
String MAC_ADDRESS = "";

// ==================== CONFIGURACION MPU6050 ====================
MPU6050 mpu;
const int MPU_SDA = 21;
const int MPU_SCL = 22;
bool mpu_disponible = false;

// ==================== CONFIGURACION HX711 ====================
const int HX711_DOUT = 18;  // Pin DT conectado a GPIO 18
const int HX711_SCK = 5;    // Pin SCK conectado a GPIO 5
HX711 scale;
bool celda_disponible = false;
float calibration_factor = 2280.0;

// ==================== LED INDICADOR ====================
const int LED_CONEXION = 2;
const int LED_PRACTICA = 13;

// ==================== CONTROL DE ESTADO ====================
bool wifi_conectado = false;
bool dispositivo_registrado = false;
bool practica_activa = false;
bool puede_enviar_datos = false;

// ==================== TIEMPOS Y CONTADORES ====================
unsigned long ultima_verificacion = 0;
unsigned long ultimo_envio = 0;
unsigned long ultimo_intento_wifi = 0;
unsigned long tiempo_inicio = 0;
unsigned long ultima_lectura_sensores = 0;  // NUEVO
unsigned long ultimo_check_sensores = 0;    // NUEVO

const unsigned long INTERVALO_VERIFICACION = 5000;
const unsigned long INTERVALO_ENVIO = 100;
const unsigned long TIMEOUT_WIFI = 20000;
const unsigned long INTERVALO_REINTENTAR_WIFI = 30000;
const unsigned long INTERVALO_MOSTRAR_SENSORES = 1000;  // NUEVO: Mostrar cada 1 segundo
const unsigned long INTERVALO_CHECK_SENSORES = 10000;  // NUEVO: Verificar sensores cada 10s

int intentos_envio_fallidos = 0;
const int MAX_INTENTOS_FALLIDOS = 10;

// ==================== ESTADISTICAS ====================
unsigned long datos_enviados_total = 0;
unsigned long errores_envio = 0;
unsigned long lecturas_mpu = 0;        // NUEVO
unsigned long lecturas_celda = 0;      // NUEVO
unsigned long errores_mpu = 0;         // NUEVO
unsigned long errores_celda = 0;       // NUEVO

// ==================== SETUP ====================
void setup() {
  Serial.begin(115200);
  delay(1000);
  
  pinMode(LED_CONEXION, OUTPUT);
  pinMode(LED_PRACTICA, OUTPUT);
  digitalWrite(LED_CONEXION, LOW);
  digitalWrite(LED_PRACTICA, LOW);
  
  imprimirBanner();
  obtenerMacAddress();
  inicializarMPU6050();
  inicializarCeldaCarga();
  conectarWiFi();
  
  if (wifi_conectado) {
    registrarDispositivo();
  }
  
  imprimirEstadoInicial();
  tiempo_inicio = millis();
  
  // NUEVO: Mensaje inicial sobre monitoreo
  Serial.println("\n[*] Monitoreo de sensores ACTIVO");
  Serial.println("[*] Los datos se mostraran cada 1 segundo\n");
}

// ==================== LOOP PRINCIPAL ====================
void loop() {
  unsigned long tiempo_actual = millis();
  
  verificarConexionWiFi();
  
  // NUEVO: Verificar estado de sensores periodicamente
  if (tiempo_actual - ultimo_check_sensores >= INTERVALO_CHECK_SENSORES) {
    verificarEstadoSensores();
    ultimo_check_sensores = tiempo_actual;
  }
  
  // NUEVO: Mostrar datos de sensores en tiempo real
  if (tiempo_actual - ultima_lectura_sensores >= INTERVALO_MOSTRAR_SENSORES) {
    mostrarDatosSensores();
    ultima_lectura_sensores = tiempo_actual;
  }
  
  if (!wifi_conectado && (tiempo_actual - ultimo_intento_wifi > INTERVALO_REINTENTAR_WIFI)) {
    Serial.println("\n[!] Reintentando conexion WiFi...");
    conectarWiFi();
    if (wifi_conectado && !dispositivo_registrado) {
      registrarDispositivo();
    }
  }
  
  if (!wifi_conectado || !dispositivo_registrado) {
    parpadearLED(LED_CONEXION, 500);
    // NOTA: Aun sin conexion, seguimos mostrando datos de sensores
  } else {
    digitalWrite(LED_CONEXION, HIGH);
  }
  
  if (tiempo_actual - ultima_verificacion >= INTERVALO_VERIFICACION) {
    verificarPracticaActiva();
    ultima_verificacion = tiempo_actual;
  }
  
  if (puede_enviar_datos && (tiempo_actual - ultimo_envio >= INTERVALO_ENVIO)) {
    enviarDatosSensores();
    ultimo_envio = tiempo_actual;
  }
  
  digitalWrite(LED_PRACTICA, puede_enviar_datos ? HIGH : LOW);
  
  if (tiempo_actual - tiempo_inicio > 60000) {
    mostrarEstadisticas();
    tiempo_inicio = tiempo_actual;
  }
  
  delay(10);
}

// ==================== FUNCIONES WiFi ====================
void obtenerMacAddress() {
  MAC_ADDRESS = WiFi.macAddress();
  Serial.println("\n========================================");
  Serial.println("   INFORMACION DEL DISPOSITIVO");
  Serial.println("========================================");
  Serial.print("MAC Address: ");
  Serial.println(MAC_ADDRESS);
}

void conectarWiFi() {
  Serial.println("\n========================================");
  Serial.println("      CONECTANDO A WiFi");
  Serial.println("========================================");
  Serial.print("SSID: ");
  Serial.println(WIFI_SSID);
  
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  
  unsigned long inicio = millis();
  int puntos = 0;
  
  while (WiFi.status() != WL_CONNECTED && (millis() - inicio < TIMEOUT_WIFI)) {
    delay(500);
    Serial.print(".");
    puntos++;
    if (puntos % 40 == 0) Serial.println();
    parpadearLED(LED_CONEXION, 100);
  }
  
  Serial.println();
  
  if (WiFi.status() == WL_CONNECTED) {
    wifi_conectado = true;
    Serial.println("\n✓ WiFi CONECTADO");
    Serial.print("  IP Address: ");
    Serial.println(WiFi.localIP());
    Serial.print("  Senal: ");
    Serial.print(WiFi.RSSI());
    Serial.println(" dBm");
    digitalWrite(LED_CONEXION, HIGH);
  } else {
    wifi_conectado = false;
    Serial.println("\n✗ ERROR: No se pudo conectar a WiFi");
    Serial.println("  Verificar:");
    Serial.println("  - SSID correcto");
    Serial.println("  - Contrasena correcta");
    Serial.println("  - Red disponible");
    digitalWrite(LED_CONEXION, LOW);
  }
  
  ultimo_intento_wifi = millis();
}

void verificarConexionWiFi() {
  if (WiFi.status() != WL_CONNECTED && wifi_conectado) {
    wifi_conectado = false;
    Serial.println("\n[!] ADVERTENCIA: WiFi desconectado");
    digitalWrite(LED_CONEXION, LOW);
  }
}

// ==================== FUNCIONES SENSORES ====================
void inicializarMPU6050() {
  Serial.println("\n========================================");
  Serial.println("     INICIALIZANDO MPU6050");
  Serial.println("========================================");
  
  Wire.begin(MPU_SDA, MPU_SCL);
  Wire.setClock(400000);
  
  delay(100);
  mpu.initialize();
  delay(100);
  
  if (mpu.testConnection()) {
    mpu_disponible = true;
    Serial.println("✓ MPU6050 detectado correctamente");
    
    mpu.setFullScaleAccelRange(MPU6050_ACCEL_FS_2);
    mpu.setFullScaleGyroRange(MPU6050_GYRO_FS_250);
    
    Serial.println("  - Rango acelerometro: +-2g");
    Serial.println("  - Rango giroscopio: +-250 grados/s");
    
    Serial.print("  - Calibrando");
    for(int i = 0; i < 3; i++) {
      delay(500);
      Serial.print(".");
    }
    Serial.println(" ✓");
    
  } else {
    mpu_disponible = false;
    Serial.println("✗ ERROR: MPU6050 no detectado");
    Serial.println("  Verificar:");
    Serial.println("  - Conexion SDA (GPIO 21)");
    Serial.println("  - Conexion SCL (GPIO 22)");
    Serial.println("  - Alimentacion 3.3V");
    Serial.println("  - Direccion I2C (0x68 o 0x69)");
  }
}

void inicializarCeldaCarga() {
  Serial.println("\n========================================");
  Serial.println("   INICIALIZANDO CELDA DE CARGA");
  Serial.println("========================================");
  Serial.print("Pines configurados: DOUT=");
  Serial.print(HX711_DOUT);
  Serial.print(" (GPIO 18), SCK=");
  Serial.print(HX711_SCK);
  Serial.println(" (GPIO 5)");
  
  scale.begin(HX711_DOUT, HX711_SCK);
  
  if (scale.wait_ready_timeout(1000)) {
    celda_disponible = true;
    Serial.println("✓ HX711 detectado correctamente");
    
    scale.set_scale(calibration_factor);
    scale.tare(10);
    
    Serial.print("  - Factor de calibracion: ");
    Serial.println(calibration_factor);
    Serial.println("  - Tara establecida");
    
  } else {
    celda_disponible = false;
    Serial.println("✗ ERROR: HX711 no responde");
    Serial.println("  Verificar:");
    Serial.println("  - Conexion DOUT (GPIO 18)");
    Serial.println("  - Conexion SCK (GPIO 5)");
    Serial.println("  - Alimentacion celda de carga");
    Serial.println("  - Cables correctamente conectados");
  }
}

// ==================== NUEVAS FUNCIONES DE MONITOREO ====================
void verificarEstadoSensores() {
  bool cambio_estado = false;
  
  // Verificar MPU6050
  if (mpu_disponible) {
    if (!mpu.testConnection()) {
      mpu_disponible = false;
      Serial.println("\n[!] ALERTA: MPU6050 desconectado");
      cambio_estado = true;
    }
  } else {
    // Intentar reconectar
    mpu.initialize();
    if (mpu.testConnection()) {
      mpu_disponible = true;
      Serial.println("\n[✓] MPU6050 reconectado");
      cambio_estado = true;
    }
  }
  
  // Verificar HX711
  if (celda_disponible) {
    if (!scale.wait_ready_timeout(100)) {
      celda_disponible = false;
      Serial.println("\n[!] ALERTA: HX711 no responde");
      cambio_estado = true;
    }
  } else {
    // Intentar reconectar
    if (scale.wait_ready_timeout(100)) {
      celda_disponible = true;
      scale.set_scale(calibration_factor);
      Serial.println("\n[✓] HX711 reconectado");
      cambio_estado = true;
    }
  }
  
  if (cambio_estado) {
    imprimirEstadoSensores();
  }
}

void mostrarDatosSensores() {
  float ax = 0, ay = 0, az = 0;
  float gx = 0, gy = 0, gz = 0;
  float pitch = 0, roll = 0;
  float fuerza = 0, presion = 0;
  bool lectura_exitosa_mpu = false;
  bool lectura_exitosa_celda = false;
  
  // Leer MPU6050
  if (mpu_disponible) {
    int16_t ax_raw, ay_raw, az_raw, gx_raw, gy_raw, gz_raw;
    mpu.getMotion6(&ax_raw, &ay_raw, &az_raw, &gx_raw, &gy_raw, &gz_raw);
    
    ax = ax_raw / 16384.0;
    ay = ay_raw / 16384.0;
    az = az_raw / 16384.0;
    gx = gx_raw / 131.0;
    gy = gy_raw / 131.0;
    gz = gz_raw / 131.0;
    
    pitch = atan2(ay, sqrt(ax * ax + az * az)) * 180.0 / PI;
    roll = atan2(ax, sqrt(ay * ay + az * az)) * 180.0 / PI;
    
    lecturas_mpu++;
    lectura_exitosa_mpu = true;
  } else {
    errores_mpu++;
  }
  
  // Leer Celda de Carga
  if (celda_disponible) {
    if (scale.wait_ready_timeout(100)) {
      fuerza = scale.get_units(3);  // Promedio de 3 lecturas para ser mas rapido
      if (fuerza < 0) fuerza = 0;
      presion = fuerza * 0.00981 / 1.0;
      
      lecturas_celda++;
      lectura_exitosa_celda = true;
    } else {
      errores_celda++;
    }
  } else {
    errores_celda++;
  }
  
  // Mostrar datos en formato compacto
  Serial.print("[SENSORES] ");
  
  // MPU6050
  if (lectura_exitosa_mpu) {
    Serial.print("MPU: ");
    Serial.print("P:");
    Serial.print(pitch, 1);
    Serial.print("° R:");
    Serial.print(roll, 1);
    Serial.print("° | ");
    Serial.print("Acc(");
    Serial.print(ax, 2);
    Serial.print(",");
    Serial.print(ay, 2);
    Serial.print(",");
    Serial.print(az, 2);
    Serial.print(") | ");
  } else {
    Serial.print("MPU: ✗ SIN DATOS | ");
  }
  
  // Celda de Carga
  if (lectura_exitosa_celda) {
    Serial.print("CELDA: ");
    Serial.print(fuerza, 1);
    Serial.print("g (");
    Serial.print(presion, 3);
    Serial.print("kPa)");
  } else {
    Serial.print("CELDA: ✗ SIN DATOS");
  }
  
  // Estado de envío
  if (puede_enviar_datos) {
    Serial.print(" | ▶ ENVIANDO");
  }
  
  Serial.println();
}

void imprimirEstadoSensores() {
  Serial.println("\n--- ESTADO DE SENSORES ---");
  Serial.print("MPU6050: ");
  Serial.println(mpu_disponible ? "✓ Activo" : "✗ Inactivo");
  Serial.print("HX711:   ");
  Serial.println(celda_disponible ? "✓ Activo" : "✗ Inactivo");
  Serial.println("--------------------------\n");
}

// ==================== FUNCIONES API ====================
void registrarDispositivo() {
  if (!wifi_conectado) {
    Serial.println("\n[!] No se puede registrar: WiFi no conectado");
    return;
  }
  
  HTTPClient http;
  String url = String(SERVER_URL) + "/registrar/";
  
  Serial.println("\n========================================");
  Serial.println("    REGISTRANDO DISPOSITIVO");
  Serial.println("========================================");
  Serial.print("URL: ");
  Serial.println(url);
  
  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  http.setTimeout(10000);
  
  StaticJsonDocument<256> doc;
  doc["mac_address"] = MAC_ADDRESS;
  doc["nombre"] = "VeinView-ESP32";
  
  String jsonString;
  serializeJson(doc, jsonString);
  
  Serial.println("Enviando datos...");
  int httpCode = http.POST(jsonString);
  
  if (httpCode > 0) {
    String response = http.getString();
    Serial.print("Codigo HTTP: ");
    Serial.println(httpCode);
    
    if (httpCode == 200 || httpCode == 201) {
      DynamicJsonDocument responseDoc(1024);
      DeserializationError error = deserializeJson(responseDoc, response);
      
      if (!error && responseDoc.containsKey("api_key")) {
        API_KEY = responseDoc["api_key"].as<String>();
        dispositivo_registrado = true;
        
        Serial.println("\n✓ DISPOSITIVO REGISTRADO EXITOSAMENTE");
        Serial.println("API Key obtenida (primeros 20 caracteres):");
        Serial.println(API_KEY.substring(0, 20) + "...");
        
      } else {
        Serial.println("\n✗ ERROR: No se pudo obtener API Key");
        Serial.println("Respuesta del servidor:");
        Serial.println(response);
      }
    } else {
      Serial.println("\n✗ ERROR en registro");
      Serial.println("Respuesta:");
      Serial.println(response);
    }
  } else {
    Serial.print("\n✗ ERROR de conexion HTTP: ");
    Serial.println(http.errorToString(httpCode));
    Serial.println("  Verificar:");
    Serial.println("  - Servidor Django corriendo");
    Serial.println("  - URL correcta en SERVER_URL");
    Serial.println("  - Firewall no bloqueando");
  }
  
  http.end();
}

void verificarPracticaActiva() {
  if (!wifi_conectado || API_KEY == "") return;
  
  HTTPClient http;
  String url = String(SERVER_URL) + "/practica-activa/?api_key=" + API_KEY;
  
  http.begin(url);
  http.setTimeout(5000);
  int httpCode = http.GET();
  
  if (httpCode == 200) {
    String response = http.getString();
    
    DynamicJsonDocument doc(1024);
    DeserializationError error = deserializeJson(doc, response);
    
    if (!error) {
      bool practica_activa_anterior = practica_activa;
      bool puede_enviar_anterior = puede_enviar_datos;
      
      practica_activa = doc["practica_activa"];
      puede_enviar_datos = doc["puede_enviar_datos"];
      
      if (practica_activa && !practica_activa_anterior) {
        String estudiante = doc["practica"]["estudiante"]["nombre_completo"].as<String>();
        String estado = doc["practica"]["estado"].as<String>();
        
        Serial.println("\n========================================");
        Serial.println("      PRACTICA INICIADA");
        Serial.println("========================================");
        Serial.print("Estudiante: ");
        Serial.println(estudiante);
        Serial.print("Estado: ");
        Serial.println(estado);
        
        datos_enviados_total = 0;
        errores_envio = 0;
      }
      
      if (puede_enviar_datos && !puede_enviar_anterior) {
        Serial.println("\n✓ Captura de datos ACTIVADA");
      }
      
      if (!puede_enviar_datos && puede_enviar_anterior) {
        Serial.println("\n⏸ Captura de datos PAUSADA");
      }
      
      if (!practica_activa && practica_activa_anterior) {
        Serial.println("\n========================================");
        Serial.println("      PRACTICA FINALIZADA");
        Serial.println("========================================");
        mostrarEstadisticas();
      }
    }
  } else if (httpCode == 401) {
    Serial.println("\n✗ ERROR: API Key invalida");
    dispositivo_registrado = false;
  } else if (httpCode < 0) {
    Serial.print("\n[!] Error de conexion: ");
    Serial.println(http.errorToString(httpCode));
  }
  
  http.end();
}

void enviarDatosSensores() {
  if (!wifi_conectado || API_KEY == "" || !puede_enviar_datos) return;
  
  if (!mpu_disponible && !celda_disponible) {
    Serial.println("[!] ADVERTENCIA: Ningun sensor disponible para enviar");
    return;
  }
  
  float ax = 0, ay = 0, az = 0;
  float gx = 0, gy = 0, gz = 0;
  float pitch = 0, roll = 0, yaw = 0;
  float fuerza = 0, presion = 0;
  
  if (mpu_disponible) {
    int16_t ax_raw, ay_raw, az_raw, gx_raw, gy_raw, gz_raw;
    mpu.getMotion6(&ax_raw, &ay_raw, &az_raw, &gx_raw, &gy_raw, &gz_raw);
    
    ax = ax_raw / 16384.0;
    ay = ay_raw / 16384.0;
    az = az_raw / 16384.0;
    gx = gx_raw / 131.0;
    gy = gy_raw / 131.0;
    gz = gz_raw / 131.0;
    
    pitch = atan2(ay, sqrt(ax * ax + az * az)) * 180.0 / PI;
    roll = atan2(ax, sqrt(ay * ay + az * az)) * 180.0 / PI;
    yaw = 0.0;
  }
  
  if (celda_disponible) {
    if (scale.wait_ready_timeout(100)) {
      fuerza = scale.get_units(5);
      if (fuerza < 0) fuerza = 0;
      presion = fuerza * 0.00981 / 1.0;
    }
  }
  
  StaticJsonDocument<512> doc;
  doc["ax"] = ax;
  doc["ay"] = ay;
  doc["az"] = az;
  doc["gx"] = gx;
  doc["gy"] = gy;
  doc["gz"] = gz;
  doc["pitch"] = pitch;
  doc["roll"] = roll;
  doc["yaw"] = yaw;
  doc["fuerza"] = fuerza;
  doc["presion"] = presion;
  
  String jsonString;
  serializeJson(doc, jsonString);
  
  HTTPClient http;
  String url = String(SERVER_URL) + "/datos/";
  
  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("X-API-Key", API_KEY);
  http.setTimeout(3000);
  
  int httpCode = http.POST(jsonString);
  
  if (httpCode == 201) {
    datos_enviados_total++;
    intentos_envio_fallidos = 0;
    // Los datos se muestran continuamente en mostrarDatosSensores()
    
  } else if (httpCode == 400) {
    puede_enviar_datos = false;
    Serial.println("\n[!] Practica pausada o finalizada");
    
  } else {
    errores_envio++;
    intentos_envio_fallidos++;
    
    if (intentos_envio_fallidos % 5 == 0) {
      Serial.print("\n✗ ERROR envio [");
      Serial.print(intentos_envio_fallidos);
      Serial.print("]: HTTP ");
      Serial.println(httpCode);
    }
    
    if (intentos_envio_fallidos >= MAX_INTENTOS_FALLIDOS) {
      Serial.println("\n[!] Demasiados errores. Reintentando registro...");
      dispositivo_registrado = false;
      registrarDispositivo();
      intentos_envio_fallidos = 0;
    }
  }
  
  http.end();
}

// ==================== FUNCIONES UTILIDAD ====================
void parpadearLED(int pin, int tiempo) {
  static unsigned long ultimo = 0;
  static bool estado = false;
  
  if (millis() - ultimo > tiempo) {
    estado = !estado;
    digitalWrite(pin, estado);
    ultimo = millis();
  }
}

void imprimirBanner() {
  Serial.println("\n\n========================================");
  Serial.println("          VEINVIEW AR - ESP32");
  Serial.println("========================================");
  Serial.println("  Sistema de Captura de Datos");
  Serial.println("  Practicas de Canalizacion Venosa");
  Serial.println("  v2.0 - Monitoreo Continuo");
  Serial.println("========================================\n");
}

void imprimirEstadoInicial() {
  Serial.println("\n========================================");
  Serial.println("      ESTADO DEL SISTEMA");
  Serial.println("========================================");
  Serial.print("WiFi: ");
  Serial.println(wifi_conectado ? "✓ Conectado" : "✗ Desconectado");
  Serial.print("MPU6050: ");
  Serial.println(mpu_disponible ? "✓ OK" : "✗ ERROR");
  Serial.print("Celda Carga: ");
  Serial.println(celda_disponible ? "✓ OK" : "✗ ERROR");
  Serial.print("Dispositivo: ");
  Serial.println(dispositivo_registrado ? "✓ Registrado" : "✗ No registrado");
  Serial.println("========================================");
}

void mostrarEstadisticas() {
  unsigned long uptime = millis() / 1000;
  int horas = uptime / 3600;
  int minutos = (uptime % 3600) / 60;
  int segundos = uptime % 60;
  
  Serial.println("\n========================================");
  Serial.println("        ESTADISTICAS DETALLADAS");
  Serial.println("========================================");
  Serial.print("Tiempo activo: ");
  Serial.print(horas);
  Serial.print("h ");
  Serial.print(minutos);
  Serial.print("m ");
  Serial.print(segundos);
  Serial.println("s");
  
  Serial.println("\n--- Datos Enviados al Servidor ---");
  Serial.print("Total enviado: ");
  Serial.println(datos_enviados_total);
  Serial.print("Errores envio: ");
  Serial.println(errores_envio);
  
  Serial.println("\n--- Lecturas de Sensores ---");
  Serial.print("MPU6050 OK: ");
  Serial.print(lecturas_mpu);
  Serial.print(" | Errores: ");
  Serial.println(errores_mpu);
  Serial.print("HX711 OK: ");
  Serial.print(lecturas_celda);
  Serial.print(" | Errores: ");
  Serial.println(errores_celda);
  
  if (wifi_conectado) {
    Serial.println("\n--- Red ---");
    Serial.print("Senal WiFi: ");
    Serial.print(WiFi.RSSI());
    Serial.println(" dBm");
  }
  
  Serial.println("========================================\n");
}
